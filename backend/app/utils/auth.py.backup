from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from app.config import get_settings
from app.database import get_supabase_admin
from app.models import TokenData, UsuarioResponse
import hashlib

settings = get_settings()
security = HTTPBearer()

# Contexto de criptografia de senha
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verifica se a senha corresponde ao hash"""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """Gera hash bcrypt da senha"""
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    """Cria token JWT"""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.access_token_expire_minutes)
    
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.secret_key, algorithm=settings.algorithm)
    return encoded_jwt

def decode_token(token: str) -> TokenData:
    """Decodifica token JWT"""
    print("=" * 60)
    print("üîì DECODIFICANDO TOKEN")
    print(f"Token recebido: {token[:30]}...")
    
    try:
        payload = jwt.decode(token, settings.secret_key, algorithms=[settings.algorithm])
        usuario_id: int = payload.get("sub")
        email: str = payload.get("email")
        
        print(f"‚úì Token v√°lido")
        print(f"‚úì Usuario ID: {usuario_id}")
        print(f"‚úì Email: {email}")
        
        if usuario_id is None:
            print("‚ùå ERRO: usuario_id n√£o encontrado no token")
            print("=" * 60)
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Token inv√°lido"
            )
        
        print("=" * 60)
        return TokenData(usuario_id=usuario_id, email=email)
    except JWTError as e:
        print(f"‚ùå ERRO JWT: {str(e)}")
        print("=" * 60)
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token inv√°lido ou expirado"
        )

async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)) -> UsuarioResponse:
    """Obt√©m o usu√°rio atual a partir do token"""
    print("=" * 60)
    print("üë§ GET CURRENT USER")
    print(f"Credentials recebido: {credentials is not None}")
    
    token = credentials.credentials
    print(f"Token extra√≠do: {token[:30]}...")
    
    token_data = decode_token(token)
    
    supabase = get_supabase_admin()
    
    # Buscar usu√°rio no banco
    result = supabase.table("usuarios").select("*").eq("id", token_data.usuario_id).single().execute()
    
    print(f"Usu√°rio encontrado no banco: {result.data is not None}")
    
    if not result.data:
        print("‚ùå ERRO: Usu√°rio n√£o encontrado no banco")
        print("=" * 60)
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Usu√°rio n√£o encontrado"
        )
    
    usuario = result.data
    print(f"‚úì Usu√°rio: {usuario.get('email')}")
    print(f"‚úì Ativo: {usuario.get('ativo')}")
    
    if not usuario.get("ativo"):
        print("‚ùå ERRO: Usu√°rio inativo")
        print("=" * 60)
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Usu√°rio inativo"
        )
    
    print("‚úÖ GET CURRENT USER - SUCESSO")
    print("=" * 60)
    return UsuarioResponse(**usuario)

def calcular_hash_documento(conteudo: str) -> str:
    """Calcula hash SHA256 de um documento"""
    return hashlib.sha256(conteudo.encode()).hexdigest()

def verificar_permissao_setor(usuario: UsuarioResponse, setor_id: int) -> bool:
    """Verifica se o usu√°rio tem permiss√£o para acessar um setor"""
    # Simplificado: usu√°rio pode acessar seu pr√≥prio setor
    # Em produ√ß√£o, implementar l√≥gica mais complexa de permiss√µes
    return usuario.setor_id == setor_id

async def get_current_active_user(current_user: UsuarioResponse = Depends(get_current_user)) -> UsuarioResponse:
    """Obt√©m usu√°rio ativo atual"""
    if not current_user.ativo:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Usu√°rio inativo"
        )
    return current_user
